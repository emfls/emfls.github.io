<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub Pages íŒŒì¼ ê²€ì‚¬ ë„êµ¬</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 300;
        }
        
        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }
        
        .main-content {
            padding: 30px;
        }
        
        .input-section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 30px;
            border-left: 5px solid #667eea;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2c3e50;
        }
        
        .form-group input, .form-group textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }
        
        .form-group input:focus, .form-group textarea:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .form-group textarea {
            height: 120px;
            resize: vertical;
            font-family: 'Courier New', monospace;
        }
        
        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        
        .btn:hover {
            transform: translateY(-2px);
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
        }
        
        .btn-copy {
            background: linear-gradient(135deg, #fd7e14 0%, #e83e8c 100%);
            font-size: 14px;
            padding: 8px 16px;
        }
        
        .results-section {
            margin-top: 30px;
        }
        
        .result-card {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 10px;
            margin-bottom: 20px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0,0,0,0.08);
        }
        
        .result-header {
            padding: 20px;
            font-weight: 600;
            font-size: 1.2em;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .result-header.success {
            background: #d4edda;
            color: #155724;
            border-left: 5px solid #28a745;
        }
        
        .result-header.warning {
            background: #fff3cd;
            color: #856404;
            border-left: 5px solid #ffc107;
        }
        
        .result-header.error {
            background: #f8d7da;
            color: #721c24;
            border-left: 5px solid #dc3545;
        }
        
        .result-content {
            padding: 20px;
        }
        
        .file-list {
            list-style: none;
            padding: 0;
        }
        
        .file-item {
            padding: 12px;
            margin-bottom: 8px;
            background: #f8f9fa;
            border-radius: 6px;
            border-left: 4px solid #667eea;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .file-item.error {
            border-left-color: #dc3545;
            background: #fff5f5;
        }
        
        .file-item.warning {
            border-left-color: #ffc107;
            background: #fffbf0;
        }
        
        .file-status {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
        }
        
        .status-valid {
            background: #d4edda;
            color: #155724;
        }
        
        .status-invalid {
            background: #f8d7da;
            color: #721c24;
        }
        
        .status-missing {
            background: #fff3cd;
            color: #856404;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }
        
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .code-preview {
            background: #f8f8f8;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 15px;
            margin-top: 10px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .error-details {
            background: #fff5f5;
            border: 1px solid #f5c6cb;
            border-radius: 6px;
            padding: 15px;
            margin-top: 10px;
            font-size: 14px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.08);
            border-top: 4px solid #667eea;
        }
        
        .stat-number {
            font-size: 2.5em;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 5px;
        }
        
        .stat-label {
            color: #666;
            font-weight: 500;
        }
        
        .sitemap-tree {
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 15px;
            margin-top: 10px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }
        
        .sitemap-level {
            margin-left: 20px;
            border-left: 2px solid #ddd;
            padding-left: 15px;
            margin-top: 10px;
        }
        
        .sitemap-file {
            color: #667eea;
            font-weight: 600;
            margin-bottom: 5px;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s ease;
        }
        
        .copy-section {
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 15px;
            margin-top: 15px;
        }
        
        .copy-textarea {
            width: 100%;
            height: 150px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            resize: vertical;
            margin-bottom: 10px;
        }
        
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #28a745;
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            z-index: 1000;
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.3s ease;
        }
        
        .toast.show {
            opacity: 1;
            transform: translateX(0);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ” GitHub Pages íŒŒì¼ ê²€ì‚¬ ë„êµ¬</h1>
            <p>ì¤‘ì²© ì‚¬ì´íŠ¸ë§µ ë¶„ì„, HTML ìœ íš¨ì„± ê²€ì‚¬, ì†ŒìŠ¤ì½”ë“œ ê²€ìƒ‰ì„ í•œ ë²ˆì—</p>
        </div>
        
        <div class="main-content">
            <div class="input-section">
                <h2>ğŸ› ï¸ ê²€ì‚¬ ì„¤ì •</h2>
                <div class="form-group">
                    <label for="repoUrl">GitHub Pages URL (ì˜ˆ: emfls.github.io)</label>
                    <input type="text" id="repoUrl" placeholder="emfls.github.io" value="emfls.github.io">
                </div>
                
                <div class="form-group">
                    <label for="searchCode">ê²€ìƒ‰í•  ì†ŒìŠ¤ì½”ë“œ (ì„ íƒì‚¬í•­)</label>
                    <textarea id="searchCode" placeholder="ê²€ìƒ‰í•˜ê³  ì‹¶ì€ HTML, CSS, JavaScript ì½”ë“œë¥¼ ì…ë ¥í•˜ì„¸ìš”..."></textarea>
                </div>
                
                <button class="btn" onclick="startAnalysis()">ğŸš€ ë¶„ì„ ì‹œì‘</button>
                <button class="btn" onclick="clearResults()">ğŸ—‘ï¸ ê²°ê³¼ ì´ˆê¸°í™”</button>
            </div>
            
            <div id="loadingSection" class="loading" style="display: none;">
                <div class="spinner"></div>
                <p id="loadingText">íŒŒì¼ì„ ë¶„ì„í•˜ê³  ìˆìŠµë‹ˆë‹¤...</p>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                </div>
            </div>
            
            <div id="resultsSection" class="results-section" style="display: none;">
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-number" id="totalFiles">0</div>
                        <div class="stat-label">ì´ íŒŒì¼ ìˆ˜</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="htmlFiles">0</div>
                        <div class="stat-label">HTML íŒŒì¼</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="sitemapFiles">0</div>
                        <div class="stat-label">ì‚¬ì´íŠ¸ë§µ íŒŒì¼</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="validFiles">0</div>
                        <div class="stat-label">ìœ íš¨í•œ íŒŒì¼</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="errorFiles">0</div>
                        <div class="stat-label">ì˜¤ë¥˜ íŒŒì¼</div>
                    </div>
                </div>
                
                <div id="sitemapResults"></div>
                <div id="htmlValidationResults"></div>
                <div id="codeSearchResults"></div>
            </div>
        </div>
    </div>
    
    <div id="toast" class="toast"></div>

    <script>
        let allFiles = [];
        let allSitemapUrls = [];
        let sitemapStructure = {};
        let analysisResults = {
            totalFiles: 0,
            htmlFiles: 0,
            sitemapFiles: 0,
            validFiles: 0,
            errorFiles: 0,
            missingFromSitemap: [],
            htmlErrors: [],
            codeMatches: [],
            sitemapErrors: [],
            allFileUrls: []
        };

        async function startAnalysis() {
            const repoUrl = document.getElementById('repoUrl').value.trim();
            const searchCode = document.getElementById('searchCode').value.trim();
            
            if (!repoUrl) {
                alert('GitHub Pages URLì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }
            
            showLoading();
            clearPreviousResults();
            
            try {
                updateProgress(10, 'ì €ì¥ì†Œ ì •ë³´ í™•ì¸ ì¤‘...');
                const repoInfo = extractRepoInfo(repoUrl);
                if (!repoInfo) {
                    throw new Error('ì˜¬ë°”ë¥¸ GitHub Pages URLì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                }
                
                updateProgress(20, 'ì‚¬ì´íŠ¸ë§µ êµ¬ì¡° ë¶„ì„ ì¤‘...');
                await fetchAllSitemaps(repoUrl);
                
                updateProgress(40, 'íŒŒì¼ ëª©ë¡ ê°€ì ¸ì˜¤ëŠ” ì¤‘...');
                await fetchAllFiles(repoInfo.owner, repoInfo.repo);
                
                updateProgress(60, 'HTML íŒŒì¼ ìœ íš¨ì„± ê²€ì‚¬ ì¤‘...');
                await validateHtmlFiles(repoUrl);
                
                if (searchCode) {
                    updateProgress(80, 'ì†ŒìŠ¤ì½”ë“œ ê²€ìƒ‰ ì¤‘...');
                    await searchInFiles(repoUrl, searchCode);
                }
                
                updateProgress(90, 'ì‚¬ì´íŠ¸ë§µ ë¹„êµ ë¶„ì„ ì¤‘...');
                compareSitemapWithFiles(repoUrl);
                
                updateProgress(100, 'ë¶„ì„ ì™„ë£Œ!');
                setTimeout(() => {
                    displayResults();
                }, 500);
                
            } catch (error) {
                console.error('ë¶„ì„ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:', error);
                hideLoading();
                alert('ë¶„ì„ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
            }
        }

        function updateProgress(percentage, text) {
            document.getElementById('progressFill').style.width = percentage + '%';
            document.getElementById('loadingText').textContent = text;
        }

        function extractRepoInfo(url) {
            const cleanUrl = url.replace(/^https?:\/\//, '').replace(/\/$/, '');
            const parts = cleanUrl.split('.');
            
            if (parts.length >= 3 && parts[1] === 'github' && parts[2] === 'io') {
                const owner = parts[0];
                const repo = cleanUrl.includes('/') ? cleanUrl.split('/')[1] : owner + '.github.io';
                return { owner, repo };
            }
            
            return null;
        }

        async function fetchAllSitemaps(baseUrl) {
            const processedSitemaps = new Set();
            const sitemapQueue = [`https://${baseUrl}/sitemap.xml`];
            
            sitemapStructure = {
                main: {
                    url: `https://${baseUrl}/sitemap.xml`,
                    urls: [],
                    childSitemaps: [],
                    error: null
                }
            };
            
            while (sitemapQueue.length > 0) {
                const currentSitemapUrl = sitemapQueue.shift();
                
                if (processedSitemaps.has(currentSitemapUrl)) {
                    continue;
                }
                
                processedSitemaps.add(currentSitemapUrl);
                
                try {
                    const response = await fetch(currentSitemapUrl);
                    
                    if (response.ok) {
                        const xmlText = await response.text();
                        const parser = new DOMParser();
                        const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
                        
                        const parseError = xmlDoc.querySelector('parsererror');
                        if (parseError) {
                            throw new Error('XML íŒŒì‹± ì˜¤ë¥˜: ' + parseError.textContent);
                        }
                        
                        const sitemapElements = xmlDoc.getElementsByTagName('sitemap');
                        if (sitemapElements.length > 0) {
                            const childSitemaps = Array.from(sitemapElements).map(sitemap => {
                                const loc = sitemap.getElementsByTagName('loc')[0];
                                return loc ? loc.textContent : '';
                            }).filter(url => url);
                            
                            if (currentSitemapUrl === `https://${baseUrl}/sitemap.xml`) {
                                sitemapStructure.main.childSitemaps = childSitemaps;
                            }
                            
                            childSitemaps.forEach(childUrl => {
                                if (!processedSitemaps.has(childUrl)) {
                                    sitemapQueue.push(childUrl);
                                    
                                    const sitemapName = childUrl.split('/').pop().replace('.xml', '');
                                    sitemapStructure[sitemapName] = {
                                        url: childUrl,
                                        urls: [],
                                        childSitemaps: [],
                                        error: null
                                    };
                                }
                            });
                        }
                        
                        const urlElements = xmlDoc.getElementsByTagName('url');
                        const urls = Array.from(urlElements).map(url => {
                            const loc = url.getElementsByTagName('loc')[0];
                            return loc ? loc.textContent : '';
                        }).filter(url => url);
                        
                        if (currentSitemapUrl === `https://${baseUrl}/sitemap.xml`) {
                            sitemapStructure.main.urls = urls;
                        } else {
                            const sitemapName = currentSitemapUrl.split('/').pop().replace('.xml', '');
                            if (sitemapStructure[sitemapName]) {
                                sitemapStructure[sitemapName].urls = urls;
                            }
                        }
                        
                        allSitemapUrls = allSitemapUrls.concat(urls);
                        
                    } else {
                        const errorMsg = `HTTP ${response.status}: ${response.statusText}`;
                        if (currentSitemapUrl === `https://${baseUrl}/sitemap.xml`) {
                            sitemapStructure.main.error = errorMsg;
                        } else {
                            const sitemapName = currentSitemapUrl.split('/').pop().replace('.xml', '');
                            if (sitemapStructure[sitemapName]) {
                                sitemapStructure[sitemapName].error = errorMsg;
                            }
                        }
                        analysisResults.sitemapErrors.push({
                            file: currentSitemapUrl,
                            error: errorMsg
                        });
                    }
                } catch (error) {
                    const errorMsg = error.message;
                    if (currentSitemapUrl === `https://${baseUrl}/sitemap.xml`) {
                        sitemapStructure.main.error = errorMsg;
                    } else {
                        const sitemapName = currentSitemapUrl.split('/').pop().replace('.xml', '');
                        if (sitemapStructure[sitemapName]) {
                            sitemapStructure[sitemapName].error = errorMsg;
                        }
                    }
                    analysisResults.sitemapErrors.push({
                        file: currentSitemapUrl,
                        error: errorMsg
                    });
                }
            }
            
            analysisResults.sitemapFiles = processedSitemaps.size;
            console.log('ì²˜ë¦¬ëœ ì‚¬ì´íŠ¸ë§µ íŒŒì¼:', processedSitemaps.size);
            console.log('ì´ ë°œê²¬ëœ URL:', allSitemapUrls.length);
        }

        async function fetchAllFiles(owner, repo) {
            try {
                const response = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/trees/main?recursive=1`);
                
                if (!response.ok) {
                    const masterResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/trees/master?recursive=1`);
                    if (!masterResponse.ok) {
                        throw new Error('ì €ì¥ì†Œì— ì ‘ê·¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                    }
                    const masterData = await masterResponse.json();
                    allFiles = masterData.tree.filter(item => item.type === 'blob');
                } else {
                    const data = await response.json();
                    allFiles = data.tree.filter(item => item.type === 'blob');
                }
                
                analysisResults.totalFiles = allFiles.length;
                analysisResults.htmlFiles = allFiles.filter(file => 
                    file.path.endsWith('.html') || file.path.endsWith('.htm')
                ).length;
                
                console.log('ë°œê²¬ëœ íŒŒì¼:', allFiles.length);
            } catch (error) {
                throw new Error('íŒŒì¼ ëª©ë¡ì„ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ' + error.message);
            }
        }

        async function validateHtmlFiles(baseUrl) {
            const htmlFiles = allFiles.filter(file => 
                file.path.endsWith('.html') || file.path.endsWith('.htm')
            );
            
            for (let i = 0; i < htmlFiles.length; i++) {
                const file = htmlFiles[i];
                const progress = 60 + (i / htmlFiles.length) * 20;
                updateProgress(progress, `HTML ê²€ì‚¬ ì¤‘... (${i + 1}/${htmlFiles.length})`);
                
                try {
                    const fileUrl = `https://${baseUrl}/${file.path}`;
                    analysisResults.allFileUrls.push(fileUrl);
                    
                    const response = await fetch(fileUrl);
                    
                    if (response.ok) {
                        const htmlContent = await response.text();
                        const errors = validateHtmlContent(htmlContent);
                        
                        if (errors.length > 0) {
                            analysisResults.htmlErrors.push({
                                file: file.path,
                                url: fileUrl,
                                errors: errors
                            });
                            analysisResults.errorFiles++;
                        } else {
                            analysisResults.validFiles++;
                        }
                    }
                } catch (error) {
                    analysisResults.htmlErrors.push({
                        file: file.path,
                        url: `https://${baseUrl}/${file.path}`,
                        errors: ['íŒŒì¼ì„ ë¡œë“œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ' + error.message]
                    });
                    analysisResults.errorFiles++;
                }
                
                await new Promise(resolve => setTimeout(resolve, 50));
            }
        }

        function validateHtmlContent(html) {
            const errors = [];
            
            if (!html.includes('<!DOCTYPE')) {
                errors.push('DOCTYPE ì„ ì–¸ì´ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤.');
            }
            
            if (!html.includes('<html')) {
                errors.push('<html> íƒœê·¸ê°€ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤.');
            }
            
            if (!html.includes('<head>')) {
                errors.push('<head> íƒœê·¸ê°€ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤.');
            }
            
            if (!html.includes('<body>')) {
                errors.push('<body> íƒœê·¸ê°€ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤.');
            }
            
            const openTags = html.match(/<[^\/][^>]*>/g) || [];
            const closeTags = html.match(/<\/[^>]*>/g) || [];
            
            const tagCounts = {};
            
            openTags.forEach(tag => {
                const tagName = tag.match(/<(\w+)/);
                if (tagName && !['img', 'br', 'hr', 'input', 'meta', 'link'].includes(tagName[1].toLowerCase())) {
                    tagCounts[tagName[1].toLowerCase()] = (tagCounts[tagName[1].toLowerCase()] || 0) + 1;
                }
            });
            
            closeTags.forEach(tag => {
                const tagName = tag.match(/<\/(\w+)/);
                if (tagName) {
                    tagCounts[tagName[1].toLowerCase()] = (tagCounts[tagName[1].toLowerCase()] || 0) - 1;
                }
            });
            
            Object.keys(tagCounts).forEach(tag => {
                if (tagCounts[tag] > 0) {
                    errors.push(`<${tag}> íƒœê·¸ê°€ ë‹«íˆì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.`);
                } else if (tagCounts[tag] < 0) {
                    errors.push(`<${tag}> íƒœê·¸ì˜ ë‹«ëŠ” íƒœê·¸ê°€ ì—¬ë¶„ì…ë‹ˆë‹¤.`);
                }
            });
            
            const unclosedAttributes = html.match(/\w+="[^"]*$/g);
            if (unclosedAttributes) {
                errors.push('ë‹«íˆì§€ ì•Šì€ ì†ì„± ê°’ì´ ìˆìŠµë‹ˆë‹¤.');
            }
            
            return errors;
        }

        async function searchInFiles(baseUrl, searchCode) {
            const searchableFiles = allFiles.filter(file => 
                file.path.endsWith('.html') || 
                file.path.endsWith('.css') || 
                file.path.endsWith('.js') ||
                file.path.endsWith('.htm')
            );
            
            for (let i = 0; i < searchableFiles.length; i++) {
                const file = searchableFiles[i];
                const progress = 80 + (i / searchableFiles.length) * 10;
                updateProgress(progress, `ì½”ë“œ ê²€ìƒ‰ ì¤‘... (${i + 1}/${searchableFiles.length})`);
                
                try {
                    const fileUrl = `https://${baseUrl}/${file.path}`;
                    const response = await fetch(fileUrl);
                    
                    if (response.ok) {
                        const content = await response.text();
                        if (content.includes(searchCode)) {
                            const lines = content.split('\n');
                            const matchingLines = [];
                            
                            lines.forEach((line, index) => {
                                if (line.includes(searchCode)) {
                                    matchingLines.push({
                                        lineNumber: index + 1,
                                        content: line.trim()
                                    });
                                }
                            });
                            
                            analysisResults.codeMatches.push({
                                file: file.path,
                                url: fileUrl,
                                matches: matchingLines
                            });
                        }
                    }
                } catch (error) {
                    console.log(`íŒŒì¼ ê²€ìƒ‰ ì‹¤íŒ¨ (${file.path}):`, error.message);
                }
                
                await new Promise(resolve => setTimeout(resolve, 30));
            }
        }

        // ê°œì„ ëœ ì‚¬ì´íŠ¸ë§µ ë¹„êµ í•¨ìˆ˜
        function compareSitemapWithFiles(baseUrl) {
            const htmlFiles = allFiles.filter(file => 
                file.path.endsWith('.html') || file.path.endsWith('.htm')
            );
            
            htmlFiles.forEach(file => {
                if (!isInSitemap(file.path, allSitemapUrls, baseUrl)) {
                    analysisResults.missingFromSitemap.push({
                        file: file.path,
                        expectedUrl: `https://${baseUrl}/${file.path}`
                    });
                }
            });
        }

        // index.html íŒŒì¼ì˜ í´ë”/ í˜•íƒœ ë§¤ì¹­ì„ ì§€ì›í•˜ëŠ” í•¨ìˆ˜
        function isInSitemap(filePath, sitemapUrls, baseUrl) {
            // ê¸°ë³¸ URL ì²´í¬
            const expectedUrl = `https://${baseUrl}/${filePath}`;
            if (sitemapUrls.includes(expectedUrl)) {
                return true;
            }
            
            // index.html íŒŒì¼ì¸ ê²½ìš° í´ë”/ í˜•íƒœë¡œë„ ì²´í¬
            if (filePath.endsWith('index.html')) {
                const folderPath = filePath.substring(0, filePath.length - 'index.html'.length);
                const folderUrl = `https://${baseUrl}/${folderPath}`;
                
                // í´ë” URLì´ ì‚¬ì´íŠ¸ë§µì— ìˆëŠ”ì§€ í™•ì¸
                if (sitemapUrls.includes(folderUrl)) {
                    return true;
                }
                
                // ë£¨íŠ¸ index.htmlì¸ ê²½ìš° ë„ë©”ì¸ ë£¨íŠ¸ URLë„ ì²´í¬
                if (folderPath === '') {
                    const rootUrl = `https://${baseUrl}/`;
                    if (sitemapUrls.includes(rootUrl)) {
                        return true;
                    }
                }
            }
            
            // ëë¶€ë¶„ ë§¤ì¹­ ì²´í¬
            for (const url of sitemapUrls) {
                if (url.endsWith(filePath)) {
                    return true;
                }
                
                // index.html íŒŒì¼ì˜ ê²½ìš° í´ë” ê²½ë¡œë¡œë„ ë§¤ì¹­ ì²´í¬
                if (filePath.endsWith('index.html')) {
                    const folderPath = filePath.substring(0, filePath.length - 'index.html'.length);
                    if (folderPath && url.endsWith(folderPath)) {
                        return true;
                    }
                }
            }
            
            return false;
        }

        function displayResults() {
            hideLoading();
            document.getElementById('resultsSection').style.display = 'block';
            
            document.getElementById('totalFiles').textContent = analysisResults.totalFiles;
            document.getElementById('htmlFiles').textContent = analysisResults.htmlFiles;
            document.getElementById('sitemapFiles').textContent = analysisResults.sitemapFiles;
            document.getElementById('validFiles').textContent = analysisResults.validFiles;
            document.getElementById('errorFiles').textContent = analysisResults.errorFiles;
            
            displaySitemapResults();
            displayHtmlValidationResults();
            displayCodeSearchResults();
        }

        function displaySitemapResults() {
            const container = document.getElementById('sitemapResults');
            const missing = analysisResults.missingFromSitemap;
            const sitemapErrors = analysisResults.sitemapErrors;
            
            let headerClass = (missing.length > 0 || sitemapErrors.length > 0) ? 'warning' : 'success';
            let headerText = '';
            
            if (sitemapErrors.length > 0) {
                headerText = `âŒ ì‚¬ì´íŠ¸ë§µ ë¶„ì„ (${sitemapErrors.length}ê°œ ì‚¬ì´íŠ¸ë§µ ì˜¤ë¥˜, ${missing.length}ê°œ íŒŒì¼ ëˆ„ë½)`;
                headerClass = 'error';
            } else if (missing.length > 0) {
                headerText = `âš ï¸ ì‚¬ì´íŠ¸ë§µ ë¶„ì„ (${missing.length}ê°œ íŒŒì¼ì´ ì‚¬ì´íŠ¸ë§µì— ëˆ„ë½ë¨)`;
            } else {
                headerText = 'âœ… ì‚¬ì´íŠ¸ë§µ ë¶„ì„ (ëª¨ë“  HTML íŒŒì¼ì´ ì‚¬ì´íŠ¸ë§µì— ë“±ë¡ë¨)';
            }
            
            let content = '';
            
            content += '<h3>ğŸ“‹ ì‚¬ì´íŠ¸ë§µ êµ¬ì¡°</h3>';
            content += '<div class="sitemap-tree">';
            content += generateSitemapTree();
            content += '</div>';
            
            if (sitemapErrors.length > 0) {
                content += '<h3>âŒ ì‚¬ì´íŠ¸ë§µ ì˜¤ë¥˜</h3>';
                content += `<ul class="file-list">`;
                sitemapErrors.forEach(error => {
                    content += `
                        <li class="file-item error">
                            <div style="width: 100%;">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <span><strong>${error.file}</strong></span>
                                    <span class="file-status status-invalid">ì˜¤ë¥˜</span>
                                </div>
                                <div class="error-details">${error.error}</div>
                            </div>
                        </li>
                    `;
                });
                content += '</ul>';
            }
            
            if (missing.length > 0) {
                content += '<h3>âš ï¸ ì‚¬ì´íŠ¸ë§µì— ëˆ„ë½ëœ íŒŒì¼</h3>';
                content += `<ul class="file-list">`;
                missing.forEach(item => {
                    content += `
                        <li class="file-item warning">
                            <span>${item.file}</span>
                            <span class="file-status status-missing">ì‚¬ì´íŠ¸ë§µ ëˆ„ë½</span>
                        </li>
                    `;
                });
                content += '</ul>';
                
                // ëˆ„ë½ëœ íŒŒì¼ ë§í¬ ë³µì‚¬ ê¸°ëŠ¥
                const missingUrls = missing.map(item => item.expectedUrl).join('\n');
                content += `
                    <div class="copy-section">
                        <h4>ğŸ“‹ ëˆ„ë½ëœ íŒŒì¼ ë§í¬ ë³µì‚¬</h4>
                        <textarea class="copy-textarea" readonly>${missingUrls}</textarea>
                        <button class="btn btn-copy" onclick="copyToClipboard('${missingUrls.replace(/\n/g, '\\n')}')">ğŸ“‹ ë³µì‚¬í•˜ê¸°</button>
                    </div>
                `;
            }
            
            if (sitemapErrors.length === 0 && missing.length === 0) {
                content += '<p>ëª¨ë“  HTML íŒŒì¼ì´ ì‚¬ì´íŠ¸ë§µì— ì ì ˆíˆ ë“±ë¡ë˜ì–´ ìˆê³ , ëª¨ë“  ì‚¬ì´íŠ¸ë§µì´ ì •ìƒì ìœ¼ë¡œ ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.</p>';
            }
            
            container.innerHTML = `
                <div class="result-card">
                    <div class="result-header ${headerClass}">
                        <span>${headerText}</span>
                        <button class="btn btn-copy" onclick="copyAllSitemapUrls()">ğŸ“‹ ì‚¬ì´íŠ¸ë§µ URL ë³µì‚¬</button>
                    </div>
                    <div class="result-content">${content}</div>
                </div>
            `;
        }

        function generateSitemapTree() {
            let tree = '';
            
            const mainSitemap = sitemapStructure.main;
            tree += `<div class="sitemap-file">ğŸ“„ sitemap.xml</div>`;
            
            if (mainSitemap.error) {
                tree += `<div style="color: #dc3545; margin-left: 20px;">âŒ ${mainSitemap.error}</div>`;
            } else {
                if (mainSitemap.urls.length > 0) {
                    tree += `<div style="margin-left: 20px; color: #28a745;">âœ… ${mainSitemap.urls.length}ê°œ URL í¬í•¨</div>`;
                }
                
                if (mainSitemap.childSitemaps.length > 0) {
                    tree += `<div style="margin-left: 20px; color: #667eea;">ğŸ”— ${mainSitemap.childSitemaps.length}ê°œ í•˜ìœ„ ì‚¬ì´íŠ¸ë§µ ì°¸ì¡°</div>`;
                    
                    mainSitemap.childSitemaps.forEach(childUrl => {
                        const sitemapName = childUrl.split('/').pop().replace('.xml', '');
                        const childSitemap = sitemapStructure[sitemapName];
                        
                        tree += `<div class="sitemap-level">`;
                        tree += `<div class="sitemap-file">ğŸ“„ ${sitemapName}.xml</div>`;
                        
                        if (childSitemap && childSitemap.error) {
                            tree += `<div style="color: #dc3545; margin-left: 20px;">âŒ ${childSitemap.error}</div>`;
                        } else if (childSitemap) {
                            tree += `<div style="margin-left: 20px; color: #28a745;">âœ… ${childSitemap.urls.length}ê°œ URL í¬í•¨</div>`;
                        }
                        
                        tree += `</div>`;
                    });
                }
            }
            
            return tree;
        }

        function displayHtmlValidationResults() {
            const container = document.getElementById('htmlValidationResults');
            const errors = analysisResults.htmlErrors;
            
            let headerClass = errors.length > 0 ? 'error' : 'success';
            let headerText = errors.length > 0 ? 
                `âŒ HTML ìœ íš¨ì„± ê²€ì‚¬ (${errors.length}ê°œ íŒŒì¼ì—ì„œ ì˜¤ë¥˜ ë°œê²¬)` : 
                'âœ… HTML ìœ íš¨ì„± ê²€ì‚¬ (ëª¨ë“  íŒŒì¼ì´ ìœ íš¨í•¨)';
            
            let content = '';
            if (errors.length > 0) {
                content = `
                    <ul class="file-list">
                        ${errors.map(item => `
                            <li class="file-item error">
                                <div style="width: 100%;">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                        <span><strong>${item.file}</strong></span>
                                        <span class="file-status status-invalid">${item.errors.length}ê°œ ì˜¤ë¥˜</span>
                                    </div>
                                    <div class="error-details">
                                        ${item.errors.map(error => `<div>â€¢ ${error}</div>`).join('')}
                                    </div>
                                </div>
                            </li>
                        `).join('')}
                    </ul>
                `;
                
                // ì˜¤ë¥˜ íŒŒì¼ ë§í¬ ë³µì‚¬ ê¸°ëŠ¥
                const errorUrls = errors.map(item => item.url).join('\n');
                content += `
                    <div class="copy-section">
                        <h4>ğŸ“‹ ì˜¤ë¥˜ íŒŒì¼ ë§í¬ ë³µì‚¬</h4>
                        <textarea class="copy-textarea" readonly>${errorUrls}</textarea>
                        <button class="btn btn-copy" onclick="copyToClipboard('${errorUrls.replace(/\n/g, '\\n')}')">ğŸ“‹ ë³µì‚¬í•˜ê¸°</button>
                    </div>
                `;
            } else {
                content = '<p>ëª¨ë“  HTML íŒŒì¼ì´ ìœ íš¨ì„± ê²€ì‚¬ë¥¼ í†µê³¼í–ˆìŠµë‹ˆë‹¤.</p>';
            }
            
            container.innerHTML = `
                <div class="result-card">
                    <div class="result-header ${headerClass}">
                        <span>${headerText}</span>
                        <button class="btn btn-copy" onclick="copyAllFileUrls()">ğŸ“‹ ëª¨ë“  íŒŒì¼ ë§í¬ ë³µì‚¬</button>
                    </div>
                    <div class="result-content">${content}</div>
                </div>
            `;
        }

        function displayCodeSearchResults() {
            const container = document.getElementById('codeSearchResults');
            const matches = analysisResults.codeMatches;
            const searchCode = document.getElementById('searchCode').value.trim();
            
            if (!searchCode) {
                container.innerHTML = '';
                return;
            }
            
            let headerClass = matches.length > 0 ? 'success' : 'warning';
            let headerText = matches.length > 0 ? 
                `ğŸ” ì½”ë“œ ê²€ìƒ‰ ê²°ê³¼ (${matches.length}ê°œ íŒŒì¼ì—ì„œ ë°œê²¬)` : 
                'ğŸ” ì½”ë“œ ê²€ìƒ‰ ê²°ê³¼ (ê²€ìƒ‰ëœ ì½”ë“œê°€ ì—†ìŒ)';
            
            let content = '';
            if (matches.length > 0) {
                content = `
                    <ul class="file-list">
                        ${matches.map(item => `
                            <li class="file-item">
                                <div style="width: 100%;">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                        <span><strong>${item.file}</strong></span>
                                        <span class="file-status status-valid">${item.matches.length}ê°œ ì¼ì¹˜</span>
                                    </div>
                                    <div class="code-preview">
                                        ${item.matches.map(match => 
                                            `<div><strong>ë¼ì¸ ${match.lineNumber}:</strong> ${escapeHtml(match.content)}</div>`
                                        ).join('')}
                                    </div>
                                </div>
                            </li>
                        `).join('')}
                    </ul>
                `;
                
                // ë§¤ì¹­ íŒŒì¼ ë§í¬ ë³µì‚¬ ê¸°ëŠ¥
                const matchUrls = matches.map(item => item.url).join('\n');
                content += `
                    <div class="copy-section">
                        <h4>ğŸ“‹ ì½”ë“œ ë§¤ì¹­ íŒŒì¼ ë§í¬ ë³µì‚¬</h4>
                        <textarea class="copy-textarea" readonly>${matchUrls}</textarea>
                        <button class="btn btn-copy" onclick="copyToClipboard('${matchUrls.replace(/\n/g, '\\n')}')">ğŸ“‹ ë³µì‚¬í•˜ê¸°</button>
                    </div>
                `;
            } else {
                content = '<p>ê²€ìƒ‰í•œ ì½”ë“œê°€ ì–´ë–¤ íŒŒì¼ì—ì„œë„ ë°œê²¬ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.</p>';
            }
            
            container.innerHTML = `
                <div class="result-card">
                    <div class="result-header ${headerClass}">
                        <span>${headerText}</span>
                        ${matches.length > 0 ? '<button class="btn btn-copy" onclick="copyCodeMatchUrls()">ğŸ“‹ ë§¤ì¹­ íŒŒì¼ ë§í¬ ë³µì‚¬</button>' : ''}
                    </div>
                    <div class="result-content">${content}</div>
                </div>
            `;
        }

        // ë³µì‚¬ ê¸°ëŠ¥ë“¤
        function copyToClipboard(text) {
            const cleanText = text.replace(/\\n/g, '\n');
            navigator.clipboard.writeText(cleanText).then(() => {
                showToast('í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!');
            }).catch(err => {
                console.error('ë³µì‚¬ ì‹¤íŒ¨:', err);
                showToast('ë³µì‚¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.', 'error');
            });
        }

        function copyAllFileUrls() {
            const urls = analysisResults.allFileUrls.join('\n');
            copyToClipboard(urls);
        }

        function copyAllSitemapUrls() {
            const urls = allSitemapUrls.join('\n');
            copyToClipboard(urls);
        }

        function copyCodeMatchUrls() {
            const urls = analysisResults.codeMatches.map(item => item.url).join('\n');
            copyToClipboard(urls);
        }

        function showToast(message, type = 'success') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = `toast ${type === 'error' ? 'error' : 'success'}`;
            toast.classList.add('show');
            
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function showLoading() {
            document.getElementById('loadingSection').style.display = 'block';
            document.getElementById('resultsSection').style.display = 'none';
        }

        function hideLoading() {
            document.getElementById('loadingSection').style.display = 'none';
        }

        function clearResults() {
            document.getElementById('resultsSection').style.display = 'none';
            clearPreviousResults();
        }

        function clearPreviousResults() {
            allFiles = [];
            allSitemapUrls = [];
            sitemapStructure = {};
            analysisResults = {
                totalFiles: 0,
                htmlFiles: 0,
                sitemapFiles: 0,
                validFiles: 0,
                errorFiles: 0,
                missingFromSitemap: [],
                htmlErrors: [],
                codeMatches: [],
                sitemapErrors: [],
                allFileUrls: []
            };
        }

        window.addEventListener('load', function() {
            console.log('GitHub Pages íŒŒì¼ ê²€ì‚¬ ë„êµ¬ê°€ ì¤€ë¹„ë˜ì—ˆìŠµë‹ˆë‹¤.');
        });
    </script>
</body>
</html>
